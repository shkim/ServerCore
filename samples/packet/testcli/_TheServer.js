// THIS FILE WAS GENERATED BY "Binary Protocol Designer tool"
// Visit https://github.com/shkim/bpdtool for more information.
"use strict";
var net = require('net');
var util = require('util');

exports.PROTOCOL_MAGIC			= 0x1234;
exports.PROTOCOL_VERSION		= 1;

// Client->Server Packet IDs:
var IDC2S_Hello				= 0;
var IDC2S_ReqNick			= 1;
var IDC2S_ReqChat			= 2;
var IDC2S_LastPacketID		= 2;

// Server->Client Packet IDs:
var IDS2C_Welcome			= 0;
var IDS2C_NoWelcome			= 1;
var IDS2C_SetNick			= 2;
var IDS2C_Chat				= 3;
var IDS2C_LastPacketID		= 3;

// Hello packet accecpted
function recv_Welcome(self, buf, offset)
{
	var pkt = new Object();

	pkt.user_count = buf.readInt32LE(offset);

	self.on_Welcome(self, pkt);
}

// version not accepted, server will disconnect
function recv_NoWelcome(self, buf, offset)
{
	var pkt = new Object();

	pkt.server_version = buf.readInt32LE(offset);

	self.on_NoWelcome(self, pkt);
}

function recv_SetNick(self, buf, offset)
{
	var pkt = new Object();

	var len_nick = buf.readUInt8(offset); offset += 1;
	if (len_nick > 0)
	{
		pkt.nick = buf.toString(undefined, offset, offset + len_nick);
	}

	self.on_SetNick(self, pkt);
}

function recv_Chat(self, buf, offset)
{
	var pkt = new Object();

	var len_nick = buf.readUInt8(offset); offset += 1;
	if (len_nick > 0)
	{
		pkt.nick = buf.toString(undefined, offset, offset + len_nick);
		offset += len_nick + 1;
	}

	var len_msg = buf.readUInt8(offset); offset += 1;
	if (len_msg > 0)
	{
		pkt.msg = buf.toString(undefined, offset, offset + len_msg);
	}

	self.on_Chat(self, pkt);
}

var PacketDispatchTable = new Array(IDS2C_LastPacketID +1);
PacketDispatchTable[IDS2C_Welcome] = recv_Welcome;
PacketDispatchTable[IDS2C_NoWelcome] = recv_NoWelcome;
PacketDispatchTable[IDS2C_SetNick] = recv_SetNick;
PacketDispatchTable[IDS2C_Chat] = recv_Chat;

function processReceive(self, recvData)
{
	var buff;
	var buffLen = recvData.length;
	if (self._curRecvPtr > 0)
	{
		recvData.copy(self._recvBuffer, self._curRecvPtr);
		buff = self._recvBuffer;
		buffLen += self._curRecvPtr;
	}
	else
	{
		buff = recvData;
	}
	
	var remainLen;
	var basePtr = 0;
	for(;;)
	{
		var pktId = buff.readUInt8(basePtr);
		if (pktId > IDS2C_LastPacketID)
		{
			console.error("packet id range over: %d", pktId);
			self.kick();
			return;
		}
		
		remainLen = buffLen - basePtr;
		if (remainLen <= 3)
			break;
		
		var pktLen = buff.readUInt16LE(basePtr + 1);
		if (pktLen <= remainLen)
		{
			var deserialFn = PacketDispatchTable[pktId];
			if (!deserialFn)
			{
				console.error("Invalid packet id: %d", pktId);
				self.kick();
				return;
			}
			
			deserialFn(self, buff, basePtr + 3);
			basePtr += pktLen;
			
			if (basePtr == buffLen)
			{
				// consumed all received buffer
				self._curRecvPtr = 0;
				return;
			}
		}
		else if (pktLen > 2048)
		{
			console.error("Unsupported too long packet length: %d (id=%d)", pktLen, pktId);
			self.kick();
			return;
		}
		else
		{
			break;
		}
	}
	
	buff.copy(self._recvBuffer, 0, basePtr, buffLen);
	self._curRecvPtr = remainLen;
}

var isCheckedHandlers = false;

function Instance()
{
	this._socket = new net.Socket();

	this._recvBuffer = new Buffer(8192);
	this._curRecvPtr = 0;

	var self = this;
		
	this._socket.on('data', function(recvData) {
		processReceive(self, recvData);
	});

	this._socket.on('close', function() {
		if (util.isFunction(self._onDisconnect))
			self._onDisconnect();
	});	
}

function checkHandlerExists(fn, pktName)
{
	if (!util.isFunction(fn))
	{
		throw new Error("bpdtool Error: Handler function for Packet '"+ pktName +"' not found.");
	}
}

Instance.prototype.connect = function(port, host, cbOnConnect)
{
	if(!isCheckedHandlers)
	{
		checkHandlerExists(this.on_Welcome, 'Welcome');
		checkHandlerExists(this.on_NoWelcome, 'NoWelcome');
		checkHandlerExists(this.on_SetNick, 'SetNick');
		checkHandlerExists(this.on_Chat, 'Chat');
		isCheckedHandlers = true;
	}

	this._socket.connect(port, host, function() {
		// socket connected
		if (util.isFunction(cbOnConnect))
			cbOnConnect();
	});	
}

Instance.prototype.kick = function()
{
	// user wants disconnect
	this._socket.destroy();
}

Instance.prototype.setOnDisconnect = function(cb)
{
	this._onDisconnect = cb;
}

exports.setPacketHandlers = function(pktCBs)
{
	for (var k in pktCBs)
	{
		Instance.prototype['on_'+k] = pktCBs[k];
	}
}

function sendPacket(self, pktId, buf, len)
{
	buf.writeUInt8(pktId, 0);
	buf.writeInt16LE(len, 1);

	if (buf.length == len)
		self._socket.write(buf);
	else
		self._socket.write(buf.slice(0,len));
}

// Client should send this packet first
Instance.prototype.send_Hello = function(magic, version)
{
	var buf = new Buffer(11);
	buf.writeUInt8(IDC2S_Hello, 0);
	buf.writeInt16LE(buf.length, 1);

	buf.writeInt32LE(magic, 3);
	buf.writeInt32LE(version, 7);

	this._socket.write(buf);
}

Instance.prototype.send_ReqNick = function(nick)
{
	var len_nick = Buffer.byteLength(nick);
	var buf = new Buffer(5 + len_nick);

	var offset = 3;
	buf.writeUInt8(len_nick, offset); offset += 1;
	if(len_nick > 0)
	{
		offset += buf.write(nick, offset);
		buf.writeInt8(0, offset); offset += 1;
	}

	sendPacket(this, IDC2S_ReqNick, buf, offset);
}

Instance.prototype.send_ReqChat = function(msg)
{
	var len_msg = Buffer.byteLength(msg);
	var buf = new Buffer(6 + len_msg);

	var offset = 3;
	buf.writeUInt16LE(len_msg, offset); offset += 2;
	if(len_msg > 0)
	{
		offset += buf.write(msg, offset);
		buf.writeInt8(0, offset); offset += 1;
	}

	sendPacket(this, IDC2S_ReqChat, buf, offset);
}

exports.Instance = Instance;
// END OF GENERATION
